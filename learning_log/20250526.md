## axios 라이브러리 이용
외부 라이브러리이기 때문에
터미널에서 npm install axios

과정
1. 터미널에서 npm install axios
2. axios를 사용하기 전에 리액트 컴포넌트 상에서 
```tsx
import axios from 'axos';
```
axios 라이브러리에는 JSON 데이터의 자동 변환 등의 이점이 있어 금요일에 수업했던 것처럼 response.json() 형태로 .json()
메서드를 호출할 필요가 없음.

```tsx
axios.get('http://someapi.com')
.then(response => consloe.log(response))
.catch(error => console.log(error));
```
위의 코드는 fetch를 사용한 .then() 구문과 비교할 것(금요일에 수업한 내용).

axios 라이브러리에는 HTTP 메서드를 호출하는 _전옹 메서드_ 가 있습니다.
예를 들어 POST 요청을 하고, 요청 본문에 객체를 전송하려는 경우 axios.post()를 사용합니다.

```tsx
axios.post('http://someapi.com', { newObject })   // 전송하고자 하는 객체
.then(response => consloe.log(response))
.catch(error => console.log(error));
```
혹은 axios() 함수를 이용하는 방법(axios.post()는 post 메서드입니다. python에서 배운 것 처럼 점을 찍고
작성하는지 아닌지에 따라 function / method의 구분이 일어난다는 점을 명심).

axios 함수 사용 예시
```tsx
const response => await axios({
  method: 'POST',
  url: 'https://myapi.com/api/cars',
  headers: { 'Content-Type': 'application/json' },
  data: { brand: 'Ford', model: 'Ranger' },
});
```

위의 예시 코드는 https://myapi.com/api/cars 엔드포인트로 POST 요청을 보냅니다. 요청 본문에는 객체가 표함되고,
Axios 라이브러리는 자동으로 데이터를 문자열화합니다(JSON 문자열 데이터로 만들어준다는 의미. 그래서 postman에서는
전체 JSON으로 작성했는데, 여기서는 JS 객체 형태로 작성).

# OpenWeather API
날씨를 보여주는 리액트 앱을 만들예정.
온도, 설명, 날씨 아이콘을 포함시킬 거고, 데이터는
https://openweathermap.org/ 에서 가져올 예정
처음 외부 데이터 수집 및 가공이 될 예정.

App.jsx가 초기화되었다고 가정한 상태에서 진행
1. 날씨 응답 데이터를 저장하는 데 필요한 상태를 추가. 앱에 온도, 설명, 날씨 아이콘을 표시할가기 떄문에, 수업한 방식 중
객체를 통해 상태
```jsx
import { useState } from 'react'
import './App.css'

function App() {
  const [ weather, setWeather ] = useState({
    temp: '',
    desc: '',
    icon: ''
  })

  return (
    <>
    </>
  )
}

export default App
```

2. REST API를 이용하는 경우에 응답을 검사하여 JSON 데이터의 포맷을 확인.
https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Meric&APIkey=1704d9c659400b5078cf97d085f660bc


```json
{
  "coord": {
    "lon": 129.0403,
    "lat": 35.1028
  },
  "weather": [
    {
      "id": 800,
      "main": "Clear",
      "description": "clear sky",
      "icon": "01d"
    }
  ],
  "base": "stations",
  "main": {
    "temp": 291.14,
    "feels_like": 290.77,
    "temp_min": 291.14,
    "temp_max": 291.14,
    "pressure": 1019,
    "humidity": 68,
    "sea_level": 1019,
    "grnd_level": 1014
  },
  "visibility": 10000,
  "wind": {
    "speed": 0.51,
    "deg": 320
  },
  "clouds": {
    "all": 0
  },
  "dt": 1748221412,
  "sys": {
    "type": 1,
    "id": 8086,
    "country": "KR",
    "sunrise": 1748204013,
    "sunset": 1748255309
  },
  "timezone": 32400,
  "id": 1838524,
  "name": "Busan",
  "cod": 200
}
```
브라우저 상의 응답 데이터를 확인했을 때 main.temp를 이용하면 온도를 조회할 수 있고,
weater[0].description과 weather[0].icon을 통해서 각각 설명과 아이콘을 조회할 수 있습니다.

3. useEffect를 사용할 예정인데, useEffect()는 상태의 변화에 따라서 렌더링을 할 것인가 말것인가를
지정할 수 있음.

최초 렌더링 시에만 api를 참조하고 싶다면 어떻게 작성했었는지 떠올릴 필요가 있음.

```jsx
import { useState, useEffect } from 'react'
import './App.css'

function App() {
  const [ weather, setWeather ] = useState({
    temp: '',
    desc: '',
    icon: ''
  });

  useEffect(() => {
    fetch('https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Meric&APIkey=1704d9c659400b5078cf97d085f660bc')
    .then(response => response.json())
    .then(result => {           // 금요일에는 data라고 주로 썼음
      setWeather({
        temp: result.main.temp,
        desc: result.weather[0].description,
        icon: result.weather[0].icon
      })
    })
    .catch(err => console.log(err));
  }, []);                       // 최초 렌더링 시에만 api를 가져와서 조회한다는 의미

  return (
    <>
    </>
  )
}

export default App
```
위의 내용을 작성하고 나서 개발자 도구 상에서 component 탭을 확인해보시면(리액트 개발자도구), weather객체에
값이 들어가있는 것을 확인할 수 있습니다.
이는 최초 렌더링이 일어났을 때 바로 setWeather 함수가 실행되기 때문입니다. 이해가 어렵다면 useEffect 개념을
다시 학습.

weather 객체에 값이 정확하게 들어가 있는 것을 확인했지만, 브라우저 상에서는 아무 것도 보이지 않음.
return ansdl `<></>` 상태이기 때문.
객체 내의 properties를 적절하게 

```jsx
import { useState, useEffect } from 'react'
import './App.css'

function App() {
  const [ weather, setWeather ] = useState({
    temp: '',
    desc: '',
  });

  useEffect(() => {
    fetch('https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=1704d9c659400b5078cf97d085f660bc')
    .then(response => response.json())
    .then(result => {           // 금요일에는 data라고 주로 썼음
      setWeather({
        temp: result.main.temp,
        desc: result.weather[0].description,
      })
    })
    .catch(err => console.log(err));
  }, []);                       // 최초 렌더링 시에만 api를 가져와서 조회한다는 의미

  if(weather.icon){
    return (
      <>
        <p>온도 : {weather.temp}</p>
        <p>설명 : {weather.desc}</p>
        <img src= {`http://openweathermap.org/img/wn/${weather.icon}@2x.png`} alt="날씨아이콘입니다"/>
      </>
    )
  } else {
    return <>로딩 중 ...</>
  }
}

export default App
```

4. 위의 코드를 통해 날씨를 구현할 수 있게 됨. 주의해야할 점은 weather.icon 내에는 string 데이터만 들어가 있기
때문에 img 태그를 통해서 불러온다고 하더라도 alt만 나오게 됩니다.
이를 조회하는 방법은
http://openweathermap.org/img/wn 에서 아이콘 코드를 추가한 후, 뒤에 @2x.png를 명시해줘야 합니다.
이상의 코드에서 img 태그를 확인하세요.

OpenWeather API를 통해서 fetch -> .then()을 통한 데이터 가지고 오기를 학습했음.
이후엔은 axios 라이브러리를 이용하여 외부 API의 정보를 가지고 올 수 있도록 할 예정입니다.
공통점과 차이점에 초점을 맞춰서 학습하기 바랍니다.

# Github API
키워드별로 리포지토리를 검색해오는 앱을 만들 예정입니다.
웹 요청에서는 axios 라이브러리를 사용할거고, TS도 연습할 예정입니다.

TS로 axios를 이용하여 GET 요청을 보내는 예제 코드를 설명하겠습니다.
```tsx
import axios from 'axios';

type MyDataType = {
  id: number;
  name: string;
}

axios.get<MyDataType>)(apiUrl)
.then(response => console.log(response))
.catch(err => console.log(err));
```

예상 데이터 타입에 없는 일부 필드에 접근하려고 하면 개발 단계 초기에 오류가 발생합니다(외부 API를 사용하고 있기 때문에
각 porperties에 어떤 값이 들어가있는지 명확하게 알지 못하는 상황이 자주발생할 수도 있음). 이 시점에서 TS는 JS로 컴파일
되며 모든 타입 정보가 제거되는ㄷ, 타입 스크립트는 런타임 작동에 영향을 미치지 않습니다. REST API가 예상과 다른 데이터를 반환
하는 경우 TS는 이를 런타임 오류로 포착할 수 없음.

## restgithub 코딩 과정

1. 리포지토리를 검색하기 위한 Github REST API의 URL
https://api.github.com/search/repositories?q=korit_3

위의 링크를 들어가서 확인해보면 JSON 데이터가 있음.
거기서 items 배열 내에 있는 객체의 full_name 속성을 가지고 옴.
그리고 html_url도 가지고 와서 클릭했을 때 해당 리포지토리를 확인할 수 있도록 작성 예정.

searchingWord에 상태가 업데이트 되었을 때, 그 결과값이 배열로 저장이 되고, 그걸 풀어서 frontend 페이지에 보여줘야함.
이 때 .map()을 사용.

그 때는 .map() 썼을 때 두 번째 argument로 index를 썼지만, 이제는 고유값을 참조할 수 있습니다.
이번에는 id를 사용.

그리고 이번에는 참조해아할 것이 있는데, useEffect()에서 두 번째 argument로 []를 쓰는 것이 불가능합니다.

```tsx
import { useState, useEffect } from 'react';
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
}

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]);

  const handleClick = () => {
    // REST API호출
  }

  return (
    <>
      <input type="text" value={keyword} onChange={event => setKeyword(event.target.value)}/>
      <br />
      <br />
      <button>검색</button>
    </>
  )
}

export default App
```

2. handleClick() 함수를 작성할 예정. 버튼을 클릭했을 때 api를 참조.
그리고 input에서 저장된 keyword를

```tsx
import { useState, useEffect } from 'react';
import axios from 'axios';
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
}

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]);

  const handleClick = () => {
    axios.get<{ items:Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error));
  }

  return (
    <>
      <input type="text" value={keyword} onChange={event => setKeyword(event.target.value)}/>
      <br />
      <br />      
      <button onClick={handleClick}>검색</button>
    </>
  )
}

export default App
```

요청을 전송하기 위해서 axios.get() 메서드를 사용. argument로 url을 집어넣었습니다.
axios에서는 .json() 호출할 필요가 없기 때문에 response.data.items로 곧장 받아올 수 있음.
itmes 배열을 repodata 상태에 저장했습니다(setRepodata를 통해서).
그리고 catch 사용해서 오류를 콘솔에 찍어낼 수 있도록 했습니다.
TS를 사용하고 있기 때문에 GET 요청에서 예상되는 데이터 타입을 정의했는데, 전체 응답이 items
속성을 포함하는 객체였습니다(전체 응답을 의미). 그리고 itmes 속성은 배열이므로 데이터 타입은
(제네릭에 쓰이는) `<{ itmes : Repository[] }>`이 됩니다.

3. 이제 불러오는 것까지는 완료했기 때문에 필요한 데이터만 뽑아내서 return 문에 작성하여
사용자들에게 보여주는 부분이 남아있음. .map()을 사용하여 data 상태를 테이블 형태로 변환할 예정.
그리고 리포지토리의 url 속성(html_url)은 `<a>`를 통해서 href 값이 되도록 하여 클릭했을 때
해당 원격 저장소로 이동할 수 있도록 작성할 예정.
예전과 달리 map()의 두 번 째 argument로 index를 사용하는 것이 아닌 id를 사용하여 고유값을
줄 수 있도록 할 예정. 혹시 keyword가 너무 마이너해서 검색결과가 없을 경우를 대비해 조건부
렌더링 형식으로 작성할 예정

# React Query 라이브러리 이용
동일한 기능을 하는(원리를 알고 있는 상태), React Query 라이브러리를 이용했을 때 코드 라인이
어떤 식으로 작성될 수 있는지 수업할 예정

리액트 쿼리 라이브러리는 데이터 캐싱 및 성능 최적화 관련 기능을 많이 제공.

데이터 캐싱 처리 컴포넌트
- QueryClientProvider, QueryClient
QueryClient 인스턴스를 생성하고, App 컴포넌트에서 QueryClientProvider를 렌더링

* 데이터 캐싱이란?
  - 애플리케이션 성능 최적화의 핵심 개념 중 하나로, 네트워크 요청이나 계산 비용이 큰 작업의 결과를
  한 번 저장해두고('캐시(cache)'), 이후 동일한 요청이 들어올 때 저장된 결과를 빠르게 재사용함으로써
  응답 시간(latency)을 단축하고 서버 부하를 줄이는 기법.

캐시(cache) - 임시 저장소(메모리, 디스크, 브라우저 스토리지 등)에 데이터를 저장해두는 공간
캐싱(caching) 
  - 데이터 요청전 - 애플리케이션은 머너 캐시에 해당 키(URL / 쿼리 매개변수)에 대응하는
  데이터가 있는지 확인(cache lookup)
  - cache hit - 캐시에 데이터가 있으면(그리고 유효하다면) 저장된 값을 즉시 반환
  - cache miss - 캐시에 데이터가 없거나 만료되었다면 원본(원격 API / DB 등)에 요청(fetch)
  -> 데이터를 받아와서 캐시에 저장한 뒤 client에게 반환

그러면 이제 리액트 쿼리와 관련지어서 코드를 작성하자면 리액트 쿼리는 네트워크 요청을 호출하는 데
이용되는 useQuery() 훅 함수가 있습니다.

```jsx
const query = useQuery({ 
    querykey: ['repositories'], 
    queryFn: getRepositories 
  });
```
- queryKey - 쿼리를 위한 고유한 키로 데이터의 캐싱과 다시 가져오기에 이용된다.
- queryFn - _데이터를 가져오는 함수이며 프로미스를 반환_

useQuery() 훅이 반환하는 query 객체에는 쿼리 상태와 같은 중요한 속성이 포함되어 있습니다.

```jsx
const { isLoading, isError, isSuccess } = useQuery({
  queryKey: ['repositories'],
  queryFn: getRepositories
});
```
- isLoading - 데이터를 아직 이용 불가능
- isError - 쿼리가 오류로 종료됨
- isSuccess - 쿼리가 성공적으로 종료되었으며, 그래서 쿼리 데이터를 이용 가능.
query 객체의 데이터 속성에는 응답이 반환하는 데이터가 포함되어있음.

```tsx
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

export default function Repositories() {
  const getRepositories = async () => {
    const response = await axios.get('https://api.github.com/search/repositories?q=korit_3');

    return response.data.items;
  }

  const { isLoading, isError, data } = useQuery({
    queryKey: ['repositories'],
    queryFn: getRepositories,
  })

  return (
    <>
    </>
  );
}
```
useQuery 흑은 import 해서 Github REST API에서 axios.get()을 호출하는 getRepositories() 함수를
정의했습니다.(axios를 사용했기 때문에 async / await을 사용했습니다 -> .then()이 아님) useQuery 훅 함수를
호출하고, queryFn 속성의 값을 fetch 관련인(axios를 썼지만) getRepositories로 만들었습니다.

3. _조건부 렌더링_ 을 구현. 리포지토리는 데이터를 이용할 수 있을 때 렌더링이 됨. 그리고 REST API 호출이
오류일 경우 isError로 끝나는 경우가 됨. 그 때도 오류 메시지를 렌더링 하도록 작업.

4. github REST API의 JSON 데이터를 분석하여 return 부분을 다양하게 뽑아낼 수 있습니다.
사용자가 어떤 정보를 접하기를 원하는지, 어떤 방식으로 보여지길 원하는지 고민해야한다고 할 수 있음.

- Github API는 요청 횟수 제한이 적용되기 때문에 조심하셔야 하는데 1분 당 10회의 요청 제한 정책을 가지고 있고,
이 한도를 넘기게 되면 1분 기다리고 다시 시작하면 됨.

```tsx
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

export default function Repositories() {
  const getRepositories = async () => {
    const response = await axios.get('https://api.github.com/search/repositories?q=korit_3');

    return response.data.items;
  }

  const { isLoading, isError, data } = useQuery({
    queryKey: ['repositories'],
    queryFn: getRepositories,
  })

  if(isLoading) {
    return <h1>데이터를 불러오는 중입니다...</h1>
  }

  if (isError) {
    return <h1>데이터를 불러오는 데 실패했습니다...</h1>
  }

  else {
    return (
      <table>
        <tbody>
          {
            data.map(repo => 
              <tr key={repo.id}>
                <td>{repo.owner.login}: </td>
                <td>
                  <a href={repo.html_url}>{repo.html_url}</a>
                </td>
              </tr>
            )
          }
        </tbody>
      </table>
    )
  }
}
```

리액트 쿼리가 데이터 관리와 캐싱을 처리하기 때문에 repodata, setRepodata(즉, 응답 데이터를 저장하기 위한)
상태가 필요하지 않습니다.
그래서 저희는 useState를 사용하지 않았음.

또한, 브라우저가 리포커싱(사용자가 애플리케이션 창이나 탭을 다른데를 들렀다가 다시 돌아왔을 때)했을 때 리액트
쿼리에 의해 자동 불러오기가 실행되는 것을 확인할 수 있습니다(즉 리포커싱할 때 다시 fetch 작업을 수행합니다.).
그래서 다른 창 보다가 다시 브라우저를 킬 경우 새로고침된 데이터를 확인할 수 있습니다.

매번 브라우저를 다른 것을 눌렀다가 들어갈 때마다 계속 새로고침이 된다면 그 것 또한 번거로운 작업이 됩니다.
그래서 데이터가 최신으로 유지되는 시간을 규정하는 핵심 속성으로 _staleTime_ 이 있습니다.

여기서 정의한 시간을 넘기면 데이터가 오래된 것으로 간주되어 백그라운드로 데이터를 다시 불러오게 됩니다.
default 값으로는 0으로 쿼리가 성공 직후 데이터가 최신이 아닌 상태로 정의되어 리포커싱할 때마다 계속 새로고침이 
일어나게 됩니다.

그래서 데이터가 자주 변경되는 것이 아니라면 staleTime 값을 설정하여 불필요한 다시 가져오기를 방지할 수 있습니다.

```jsx
const { isLoading, isError, data } = useQuery({
  queryKey: ['repositories'],
  queryFn: getRepositories,
  staleTime: 60 * 1000,   // 밀리초 단위이기 때문에 -> 1분에 해당함.
})
```

github API를 통해서 GET을 처리하는 방법을 배움. 나머지 CRUD 부분은 cardatabase를 하면서 useQuery를 사용할 예정.
useMutation() 훅이 좀 중요함.

# 유용한 리액트용 서드파티 컴포넌트

## 서드파티 리액트 컴포넌트 설치 방식
필요한 컴포넌트를 찾을 수 있어야 함.
chrome -> google에서 awesome-react-components 검색하면 github 페이지 하나 나오는데 거기서 필요한 컴포넌트(예를 들어서)

https://github.com/brillout/awesome-react-components

콤포넌트 설치 관련 과정
공식 문서의 흐름을 따라가는게 베스트입니다.

npm install component_name

- npm install을 하게 되면 package.json 파일에 컴포넌트에 의존성을 추가하게 됩니다.
  - Java에서는 build.gradle에 저희가 직접 추가하는 방식이었습니다.

특정 버전을 설치하기 위해서는
npm install component_name@version
과 같은 방식으로 작성하면 됩니다.

react-date-picker 설치 방법
npm install react-date-picker@10.0.3
으로 설치

### 설치시 
npm install component_name@version

### 삭제시
npm uninstall component_name

### 오래된 컴포넌트 확인
npm outdated

### 컴포넌트 업데이트
npm update

### 전체 프로젝트 의존성 확인
npm list
-> 다만 그냥 package.json 들어가서 dependencies를 확인