npm install @mui/material@5.17.1
npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @tanstack/react-query@4.36.1
npm install axios

```tsx
import { AppBar, Toolbar, Typography, Container, CssBaseline } from '@mui/material'

import './App.css'

function App() {
  return (
    <Container maxWidth="xl">
    <CssBaseline />
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">
            Car Shop | 자동차 거래소
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App
```
- Container
  - 기본 레이아웃 컴포넌트에 해당하는데, 앱 컨텐츠를 가로로 중앙에 배치함
  - maxWidth를 통해 사이즈를 지정, 앱의 최대 너비(가로 길이)
- AppBar
  - position 프롭을 가지며, static으로 지정할 시 스크롤을 내릴 떄 앱 바가 상단에 고정되지 않고 사라지게 됨.
  fixed일 경우 앱 바가 상단에 고정돼있음.
- CssBaseline
  - 여러 브라우저에서 리액트 앱의 모양이 균일하게 할 수 있도록 통제하는 Component
  - 보통 이 컴포넌트는 최상위 레벨에 포함되어 스타일이 전역적으로 적용되게끔 합니다.
물론 위를 적용하기 위해서는 main.tsx에서 index.css import문을 삭제해줘야 합니다.

https://github.com/mui/material-ui
https://mui.com/material-ui/getting-started/

# CRUD 기능 추가하기

```tsx
<QueryClientProvider client={queryClient}>

</QueryClientProvider>
```

## 백엔드에서 데이터 가져오기

```json
{
    "brand": "Kia",
    "model": "Seltos",
    "color": "Chacoal",
    "registrationNumber": "360수5690",
    "modelYear": 2020,
    "price": 28000,
    "_links": {
        "self": {
            "href": "http://localhost:8080/api/cars/4"
        },
        "car": {
            "href": "http://localhost:8080/api/cars/4"
        },
        "owner": {
            "href": "http://localhost:8080/api/cars/4/owner"
        }
    }
}
```
위의 JSON 데이터를 바탕으로 types.ts에 CarResponse 데이터의 자료형들을 정의했습니다.

http://localhost:8080/api/cars 엔드 포인트로 GET요청을 날려서 백엔드에서 자동차 데이터를 가져오는 함수를 정의.
이 함수는 CarResponse 객체 배열을 포함한 _프로미스_ 를 반환
-> fetch() / axios 사용했을 때 했었음.

```tsx
import { useQuery } from "@tanstack/react-query";
import { CarResponse } from "../types";
import axios from "axios";

export default function Carlist(){
  const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get('http://localhost:8080/api/cars');

    return response.data._embedded.cars;
  }

  const { data, error, isSuccess } = useQuery({
    queryKey: ['cars'],
    queryFn: getCars
  })

  return (
    <>
    </>
  );
}
```
- 참고 사항 - useQuery 혹은 데이터를 가져오지도 않고 데이터의 자료형 또한 모르기 때문에 타입스크립트 제네릭을 사용합니다. 
그런데 리엑트는 데이터의 자료형을 유추할 수 있으므로 수동 처리를 하지 않았습니다. 원래 제네릭을 대놓고 쓰는 방식은 이하와 같습니다.

```tsx
const { data, error, isSuccess } = useQuery<CarResponse[], Error>({
  queryKey: ['cars'],
  queryFn: getCars
})
```

return 파트 아무것도 안썼는데, useQuery 썼을 때 _조건부 렌더링_ 을 했었습니다. 성공했을 때, 실패했을 때 기준으로 작성한거 떠올리시면 됩니다.

JS 배열 형태로 Table 작성

## 환경 변수 이용

백엔드가 로컬 호스트가 아닌 다른 서버에 배포가 된다고 가정했을 때 더이상 localhost:8080을 쓰지 않게 됩니다.
그러면 그때마다 백/프론트에 localhost:8080을 검색해서 하나하나 바꾼다고 생각하면 오류가 발생할 가능성이 높다는 것을 이해할 수 있습니다.

그리고 Java 때부터 설명하던 하드코딩이 그 때도 적용된다고 볼 수 있습니다.

그래서 환경 변수를 이용하여 URL 값이 바뀌더라도 한 군데만 수정해도 되도록 작성할 예정입니다.

vite 프로젝트의 경우 

앱의 루트 폴더에 `.env` 파일을 생성
```env
VITE_API_URL = http://localhost:8080
```

src 하위 폴더에 api 폴더를 생성 -> carapi.ts 파일 생성

이상의 과정 이유 - 모든 API 호출 함수를 자체 모듈로 분리 -> getCars()라는 함수가 현재 Carlist 컴포넌트에서만 사용하고 있지만, 혹시 다른 컴포넌트A에서 사용하게 될 수도 있음. 그러면 그때마다 다른 컴포넌트A, B, C 등에서 Carlist 컴포넌트를 통째로 다 import 하게 되면 리소스 낭비에 해당함.

```ts
// carapi.ts
import axios from "axios";
import { CarResponse } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
  const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);

  return response.data._embedded.cars;
}
```
위의 설명 내용을 적용한 코드가 위와 같습니다.
여기서 중요한 점은 fetch 받아오게 되는 경우에 명시하는 URL을 .env에서 불러오기 위해서는 `import.meta.env.환경_변수명` 으로 작성해야 한다는 점입니다. 그리고 나머지 엔드포인트만 string 형태로 작성해주면 배포 이후나 포트 번호가 바뀌더라도 .env의 VITE_API_URL만 수정해주시면 나머지 부분은 변수를 받아오는 형태이기 때문에 오류 발생의 가능성은 낮아지고 유지보수성이 높아진다고 할 수 있습니다.

## 페이징, 필터링, 정렬
AG-Grid말고 다른 것을 사용할 예정.